# Spring Security

## Journey

### Console Based Authentication

- Created project using Spring Initializer.
- Created dashboard pages and tested by commenting out Spring Security.
  - Created `@Controller` (because `@RestController` won't work) and returned views based on URL.
  - Created `dashboard.html` inside `resources/templates` folder and returned it in the `@Controller` class.
  - Created `dashboard_developer.html` inside `resources/templates` folder and returned it in the `@Controller` class.
  - Created `dashboard_hr.html` inside `resources/templates` folder and returned it in the `@Controller` class.
  - Created `dashboard_manager.html` inside `resources/templates` folder and returned it in the `@Controller` class.
- Made the above `dashboard.html` the landing page after login.
  - Created `SecurityConfig` with a custom `SecurityFilterChain` bean.
  - Made all URLs authenticated except `/login`.
  - Customized `successForwardUrl` to land on the `dashboard` page after login.
- Tried login with username `user` and password printed in the console.
  - Since no authentication manager was provided, only the password generated by Spring could be used for login.
- Encountered a 405 error saying POST method not supported; the `successForwardUrl` redirection to the dashboard was causing the issue.
  - The issue was because the redirection happened as a POST request to the `dashboard` page.
  - To fix it, created another `@PostMapping` for the dashboard method similar to `@GetMapping`.
- Success! Authentication from login to the dashboard page is working.

### In-Memory Based Authentication

- In the previous method, login could be done only with one credential where the password was generated by Spring. Now it will be moved to code.
- Created a custom `UserDetailsService` to return `InMemoryUserDetailsManager` with predefined users.
  - The goal was to create a `UserDetails` object.
  - The password is hardcoded as an encoded value using Bcrypt encoder.
  - Created a `BCryptPasswordEncoder` bean to decode it.
- Added roles to the User class, and protected the dashboard admin and guest pages by those roles.
- For users who don't have access, a new 403 page is returned, which is placed in `resources/public/error/`.
- Customized the login page by creating a new login HTML file inside the `resources/templates` folder and customized it in `PagesController`.
- Disabled CSRF, else login wouldn't work.

### Database Based Authentication

- Upgraded from In-Memory based, as the credentials were hardcoded and users were not expandable.
- Used MySQL as the database, to align with [MySQL](../../MySQL) folder.
- Changed project context from normal users to employees; going forward, login happens via employee ID, not username. Adjusted `usernameParameter` accordingly.
- Created `EmployeeEntity` entity and `EmployeeRepository` DAO, along with `RoleEntity`. 
- Commented out the in-memory based `UserDetailsService` bean and created a new class `FromDatabaseUserDetailsService` for the bean.
- The new `FromDatabaseUserDetailsService` connects to the database and creates a `UserDetails` class.
- To permit access to `/h2-console`, customized the `webSecurityCustomizer` bean, if H2 is used.
